{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\sahar\\\\OneDrive\\\\Desktop\\\\New folder\\\\package\\\\client\\\\src\\\\contexts\\\\SocketContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useEffect, useRef, useState } from 'react';\nimport io from 'socket.io-client';\nimport { toast } from 'react-toastify';\nimport { useAuth } from './AuthContext';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SocketContext = /*#__PURE__*/createContext();\nexport const useSocket = () => {\n  _s();\n  const context = useContext(SocketContext);\n  if (!context) {\n    throw new Error('useSocket must be used within a SocketProvider');\n  }\n  return context;\n};\n_s(useSocket, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport const SocketProvider = ({\n  children\n}) => {\n  _s2();\n  const {\n    user\n  } = useAuth();\n  const [socket, setSocket] = useState(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [roomUsers, setRoomUsers] = useState([]);\n  const [currentRoom, setCurrentRoom] = useState(null);\n  const peersRef = useRef({});\n  const localStreamRef = useRef(null);\n  useEffect(() => {\n    if (user) {\n      // Initialize socket connection\n      const newSocket = io('http://localhost:5000');\n      newSocket.on('connect', () => {\n        console.log('ðŸ”Œ Socket connected:', newSocket.id);\n        setIsConnected(true);\n      });\n      newSocket.on('disconnect', () => {\n        console.log('ðŸ”Œ Socket disconnected');\n        setIsConnected(false);\n      });\n      newSocket.on('connect_error', error => {\n        console.error('ðŸ”Œ Socket connection error:', error);\n        toast.error('Connection error. Please check your internet connection.');\n      });\n\n      // Room management events\n      newSocket.on('room-users', ({\n        users\n      }) => {\n        console.log('ðŸ‘¥ Users in room:', users);\n        setRoomUsers(users);\n      });\n      newSocket.on('user-joined', ({\n        userName,\n        socketId\n      }) => {\n        console.log('ðŸ‘¤ User joined:', userName, socketId);\n        setRoomUsers(prev => [...prev, {\n          userName,\n          socketId\n        }]);\n        toast.info(`${userName} joined the room`);\n      });\n      newSocket.on('user-left', ({\n        socketId,\n        userName\n      }) => {\n        console.log('ðŸ‘¤ User left:', userName, socketId);\n        setRoomUsers(prev => prev.filter(user => user.socketId !== socketId));\n\n        // Clean up peer connection\n        if (peersRef.current[socketId]) {\n          peersRef.current[socketId].destroy();\n          delete peersRef.current[socketId];\n        }\n        toast.info(`${userName || 'A user'} left the room`);\n      });\n\n      // WebRTC signaling events\n      newSocket.on('offer', async ({\n        offer,\n        senderSocketId,\n        senderUserName\n      }) => {\n        await handleOffer(offer, senderSocketId, senderUserName);\n      });\n      newSocket.on('answer', async ({\n        answer,\n        senderSocketId\n      }) => {\n        await handleAnswer(answer, senderSocketId);\n      });\n      newSocket.on('ice-candidate', async ({\n        candidate,\n        senderSocketId\n      }) => {\n        await handleIceCandidate(candidate, senderSocketId);\n      });\n\n      // Screen sharing events\n      newSocket.on('screen-share-started', ({\n        socketId,\n        userName\n      }) => {\n        toast.info(`${userName} started screen sharing`);\n        // You can implement UI changes here\n      });\n      newSocket.on('screen-share-stopped', ({\n        socketId\n      }) => {\n        toast.info('Screen sharing stopped');\n        // You can implement UI changes here\n      });\n\n      // Error handling\n      newSocket.on('error', ({\n        message\n      }) => {\n        toast.error(message);\n      });\n      setSocket(newSocket);\n      return () => {\n        cleanup();\n      };\n    }\n  }, [user]);\n\n  // Cleanup function\n  const cleanup = () => {\n    if (socket) {\n      // Emit leave-room event before disconnecting\n      if (currentRoom) {\n        socket.emit('leave-room', {\n          roomId: currentRoom\n        });\n      }\n      socket.close();\n    }\n    setSocket(null);\n    setIsConnected(false);\n    setRoomUsers([]);\n    setCurrentRoom(null);\n\n    // Clean up all peer connections\n    Object.values(peersRef.current).forEach(peer => {\n      if (peer) peer.destroy();\n    });\n    peersRef.current = {};\n\n    // Stop local stream\n    if (localStreamRef.current) {\n      localStreamRef.current.getTracks().forEach(track => track.stop());\n      localStreamRef.current = null;\n    }\n  };\n\n  // WebRTC helper functions\n  const createPeerConnection = (targetSocketId, isInitiator) => {\n    const configuration = {\n      iceServers: [{\n        urls: 'stun:stun.l.google.com:19302'\n      }, {\n        urls: 'stun:stun1.l.google.com:19302'\n      }]\n    };\n    const peer = new RTCPeerConnection(configuration);\n\n    // Add local stream to peer connection\n    if (localStreamRef.current) {\n      localStreamRef.current.getTracks().forEach(track => {\n        peer.addTrack(track, localStreamRef.current);\n      });\n    }\n\n    // Handle ICE candidates\n    peer.onicecandidate = event => {\n      if (event.candidate && socket) {\n        socket.emit('ice-candidate', {\n          targetSocketId,\n          candidate: event.candidate\n        });\n      }\n    };\n\n    // Handle remote stream\n    peer.ontrack = event => {\n      const remoteStream = event.streams[0];\n      // You can emit this to components that need it\n      window.dispatchEvent(new CustomEvent('remote-stream', {\n        detail: {\n          socketId: targetSocketId,\n          stream: remoteStream\n        }\n      }));\n    };\n\n    // Handle connection state changes\n    peer.onconnectionstatechange = () => {\n      console.log(`Peer connection state with ${targetSocketId}:`, peer.connectionState);\n      if (peer.connectionState === 'failed' || peer.connectionState === 'disconnected') {\n        // Clean up failed connection\n        if (peersRef.current[targetSocketId]) {\n          peer.destroy();\n          delete peersRef.current[targetSocketId];\n        }\n      }\n    };\n    peersRef.current[targetSocketId] = peer;\n    return peer;\n  };\n  const handleOffer = async (offer, senderSocketId, senderUserName) => {\n    try {\n      const peer = createPeerConnection(senderSocketId, false);\n      await peer.setRemoteDescription(new RTCSessionDescription(offer));\n      const answer = await peer.createAnswer();\n      await peer.setLocalDescription(answer);\n      socket.emit('answer', {\n        targetSocketId: senderSocketId,\n        answer\n      });\n    } catch (error) {\n      console.error('Error handling offer:', error);\n    }\n  };\n  const handleAnswer = async (answer, senderSocketId) => {\n    try {\n      const peer = peersRef.current[senderSocketId];\n      if (peer) {\n        await peer.setRemoteDescription(new RTCSessionDescription(answer));\n      }\n    } catch (error) {\n      console.error('Error handling answer:', error);\n    }\n  };\n  const handleIceCandidate = async (candidate, senderSocketId) => {\n    try {\n      const peer = peersRef.current[senderSocketId];\n      if (peer) {\n        await peer.addIceCandidate(new RTCIceCandidate(candidate));\n      }\n    } catch (error) {\n      console.error('Error handling ICE candidate:', error);\n    }\n  };\n  const joinRoom = async (roomId, userName) => {\n    if (!socket) {\n      toast.error('Not connected to server');\n      return false;\n    }\n    try {\n      socket.emit('join-room', {\n        roomId,\n        userName\n      });\n      setCurrentRoom(roomId);\n      return true;\n    } catch (error) {\n      console.error('Error joining room:', error);\n      toast.error('Failed to join room');\n      return false;\n    }\n  };\n  const leaveRoom = () => {\n    if (socket && currentRoom) {\n      // Emit leave-room event to server\n      socket.emit('leave-room', {\n        roomId: currentRoom\n      });\n      setCurrentRoom(null);\n      setRoomUsers([]);\n\n      // Clean up all peer connections\n      Object.values(peersRef.current).forEach(peer => {\n        if (peer) peer.destroy();\n      });\n      peersRef.current = {};\n\n      // Stop local stream\n      if (localStreamRef.current) {\n        localStreamRef.current.getTracks().forEach(track => track.stop());\n        localStreamRef.current = null;\n      }\n      toast.info('Left the room');\n    }\n  };\n  const getLocalStream = async (video = true, audio = true) => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        video: video ? {\n          width: {\n            ideal: 1280\n          },\n          height: {\n            ideal: 720\n          },\n          frameRate: {\n            ideal: 30\n          }\n        } : false,\n        audio: audio ? {\n          echoCancellation: true,\n          noiseSuppression: true,\n          autoGainControl: true\n        } : false\n      });\n      localStreamRef.current = stream;\n      return stream;\n    } catch (error) {\n      console.error('Error accessing media devices:', error);\n      toast.error('Failed to access camera/microphone');\n      throw error;\n    }\n  };\n  const startCall = async targetSocketId => {\n    try {\n      const peer = createPeerConnection(targetSocketId, true);\n      const offer = await peer.createOffer();\n      await peer.setLocalDescription(offer);\n      socket.emit('offer', {\n        targetSocketId,\n        offer\n      });\n    } catch (error) {\n      console.error('Error starting call:', error);\n      toast.error('Failed to start call');\n    }\n  };\n  const toggleVideo = () => {\n    if (localStreamRef.current) {\n      const videoTrack = localStreamRef.current.getVideoTracks()[0];\n      if (videoTrack) {\n        videoTrack.enabled = !videoTrack.enabled;\n        return videoTrack.enabled;\n      }\n    }\n    return false;\n  };\n  const toggleAudio = () => {\n    if (localStreamRef.current) {\n      const audioTrack = localStreamRef.current.getAudioTracks()[0];\n      if (audioTrack) {\n        audioTrack.enabled = !audioTrack.enabled;\n        return audioTrack.enabled;\n      }\n    }\n    return false;\n  };\n  const startScreenShare = async () => {\n    try {\n      const screenStream = await navigator.mediaDevices.getDisplayMedia({\n        video: true,\n        audio: true\n      });\n\n      // Replace video track in all peer connections\n      const videoTrack = screenStream.getVideoTracks()[0];\n      Object.values(peersRef.current).forEach(peer => {\n        const sender = peer.getSenders().find(s => s.track && s.track.kind === 'video');\n        if (sender) {\n          sender.replaceTrack(videoTrack);\n        }\n      });\n\n      // Listen for screen share end\n      videoTrack.onended = () => {\n        stopScreenShare();\n      };\n      socket.emit('screen-share-started');\n      return screenStream;\n    } catch (error) {\n      console.error('Error starting screen share:', error);\n      toast.error('Failed to start screen sharing');\n      throw error;\n    }\n  };\n  const stopScreenShare = async () => {\n    try {\n      // Get camera stream back\n      const cameraStream = await navigator.mediaDevices.getUserMedia({\n        video: true,\n        audio: true\n      });\n      const videoTrack = cameraStream.getVideoTracks()[0];\n\n      // Replace screen track with camera track in all peer connections\n      Object.values(peersRef.current).forEach(peer => {\n        const sender = peer.getSenders().find(s => s.track && s.track.kind === 'video');\n        if (sender) {\n          sender.replaceTrack(videoTrack);\n        }\n      });\n\n      // Update local stream\n      if (localStreamRef.current) {\n        const oldVideoTrack = localStreamRef.current.getVideoTracks()[0];\n        if (oldVideoTrack) {\n          localStreamRef.current.removeTrack(oldVideoTrack);\n          oldVideoTrack.stop();\n        }\n        localStreamRef.current.addTrack(videoTrack);\n      }\n      socket.emit('screen-share-stopped');\n      return cameraStream;\n    } catch (error) {\n      console.error('Error stopping screen share:', error);\n      toast.error('Failed to stop screen sharing');\n      throw error;\n    }\n  };\n  const value = {\n    socket,\n    isConnected,\n    roomUsers,\n    currentRoom,\n    joinRoom,\n    leaveRoom,\n    getLocalStream,\n    startCall,\n    toggleVideo,\n    toggleAudio,\n    startScreenShare,\n    stopScreenShare,\n    localStream: localStreamRef.current\n  };\n  return /*#__PURE__*/_jsxDEV(SocketContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 417,\n    columnNumber: 5\n  }, this);\n};\n_s2(SocketProvider, \"1YqYqBfg0w/dp57oKSMp+I6fYR4=\", false, function () {\n  return [useAuth];\n});\n_c = SocketProvider;\nvar _c;\n$RefreshReg$(_c, \"SocketProvider\");","map":{"version":3,"names":["React","createContext","useContext","useEffect","useRef","useState","io","toast","useAuth","jsxDEV","_jsxDEV","SocketContext","useSocket","_s","context","Error","SocketProvider","children","_s2","user","socket","setSocket","isConnected","setIsConnected","roomUsers","setRoomUsers","currentRoom","setCurrentRoom","peersRef","localStreamRef","newSocket","on","console","log","id","error","users","userName","socketId","prev","info","filter","current","destroy","offer","senderSocketId","senderUserName","handleOffer","answer","handleAnswer","candidate","handleIceCandidate","message","cleanup","emit","roomId","close","Object","values","forEach","peer","getTracks","track","stop","createPeerConnection","targetSocketId","isInitiator","configuration","iceServers","urls","RTCPeerConnection","addTrack","onicecandidate","event","ontrack","remoteStream","streams","window","dispatchEvent","CustomEvent","detail","stream","onconnectionstatechange","connectionState","setRemoteDescription","RTCSessionDescription","createAnswer","setLocalDescription","addIceCandidate","RTCIceCandidate","joinRoom","leaveRoom","getLocalStream","video","audio","navigator","mediaDevices","getUserMedia","width","ideal","height","frameRate","echoCancellation","noiseSuppression","autoGainControl","startCall","createOffer","toggleVideo","videoTrack","getVideoTracks","enabled","toggleAudio","audioTrack","getAudioTracks","startScreenShare","screenStream","getDisplayMedia","sender","getSenders","find","s","kind","replaceTrack","onended","stopScreenShare","cameraStream","oldVideoTrack","removeTrack","value","localStream","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/sahar/OneDrive/Desktop/New folder/package/client/src/contexts/SocketContext.js"],"sourcesContent":["import React, { createContext, useContext, useEffect, useRef, useState } from 'react';\nimport io from 'socket.io-client';\nimport { toast } from 'react-toastify';\nimport { useAuth } from './AuthContext';\n\nconst SocketContext = createContext();\n\nexport const useSocket = () => {\n  const context = useContext(SocketContext);\n  if (!context) {\n    throw new Error('useSocket must be used within a SocketProvider');\n  }\n  return context;\n};\n\nexport const SocketProvider = ({ children }) => {\n  const { user } = useAuth();\n  const [socket, setSocket] = useState(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [roomUsers, setRoomUsers] = useState([]);\n  const [currentRoom, setCurrentRoom] = useState(null);\n  const peersRef = useRef({});\n  const localStreamRef = useRef(null);\n\n  useEffect(() => {\n    if (user) {\n      // Initialize socket connection\n      const newSocket = io('http://localhost:5000');\n      \n      newSocket.on('connect', () => {\n        console.log('ðŸ”Œ Socket connected:', newSocket.id);\n        setIsConnected(true);\n      });\n\n      newSocket.on('disconnect', () => {\n        console.log('ðŸ”Œ Socket disconnected');\n        setIsConnected(false);\n      });\n\n      newSocket.on('connect_error', (error) => {\n        console.error('ðŸ”Œ Socket connection error:', error);\n        toast.error('Connection error. Please check your internet connection.');\n      });\n\n      // Room management events\n      newSocket.on('room-users', ({ users }) => {\n        console.log('ðŸ‘¥ Users in room:', users);\n        setRoomUsers(users);\n      });\n\n      newSocket.on('user-joined', ({ userName, socketId }) => {\n        console.log('ðŸ‘¤ User joined:', userName, socketId);\n        setRoomUsers(prev => [...prev, { userName, socketId }]);\n        toast.info(`${userName} joined the room`);\n      });\n\n      newSocket.on('user-left', ({ socketId, userName }) => {\n        console.log('ðŸ‘¤ User left:', userName, socketId);\n        setRoomUsers(prev => prev.filter(user => user.socketId !== socketId));\n        \n        // Clean up peer connection\n        if (peersRef.current[socketId]) {\n          peersRef.current[socketId].destroy();\n          delete peersRef.current[socketId];\n        }\n        \n        toast.info(`${userName || 'A user'} left the room`);\n      });\n\n      // WebRTC signaling events\n      newSocket.on('offer', async ({ offer, senderSocketId, senderUserName }) => {\n        await handleOffer(offer, senderSocketId, senderUserName);\n      });\n\n      newSocket.on('answer', async ({ answer, senderSocketId }) => {\n        await handleAnswer(answer, senderSocketId);\n      });\n\n      newSocket.on('ice-candidate', async ({ candidate, senderSocketId }) => {\n        await handleIceCandidate(candidate, senderSocketId);\n      });\n\n      // Screen sharing events\n      newSocket.on('screen-share-started', ({ socketId, userName }) => {\n        toast.info(`${userName} started screen sharing`);\n        // You can implement UI changes here\n      });\n\n      newSocket.on('screen-share-stopped', ({ socketId }) => {\n        toast.info('Screen sharing stopped');\n        // You can implement UI changes here\n      });\n\n      // Error handling\n      newSocket.on('error', ({ message }) => {\n        toast.error(message);\n      });\n\n      setSocket(newSocket);\n\n      return () => {\n        cleanup();\n      };\n    }\n  }, [user]);\n\n  // Cleanup function\n  const cleanup = () => {\n    if (socket) {\n      // Emit leave-room event before disconnecting\n      if (currentRoom) {\n        socket.emit('leave-room', { roomId: currentRoom });\n      }\n      socket.close();\n    }\n    setSocket(null);\n    setIsConnected(false);\n    setRoomUsers([]);\n    setCurrentRoom(null);\n    \n    // Clean up all peer connections\n    Object.values(peersRef.current).forEach(peer => {\n      if (peer) peer.destroy();\n    });\n    peersRef.current = {};\n    \n    // Stop local stream\n    if (localStreamRef.current) {\n      localStreamRef.current.getTracks().forEach(track => track.stop());\n      localStreamRef.current = null;\n    }\n  };\n\n  // WebRTC helper functions\n  const createPeerConnection = (targetSocketId, isInitiator) => {\n    const configuration = {\n      iceServers: [\n        { urls: 'stun:stun.l.google.com:19302' },\n        { urls: 'stun:stun1.l.google.com:19302' },\n      ]\n    };\n\n    const peer = new RTCPeerConnection(configuration);\n\n    // Add local stream to peer connection\n    if (localStreamRef.current) {\n      localStreamRef.current.getTracks().forEach(track => {\n        peer.addTrack(track, localStreamRef.current);\n      });\n    }\n\n    // Handle ICE candidates\n    peer.onicecandidate = (event) => {\n      if (event.candidate && socket) {\n        socket.emit('ice-candidate', {\n          targetSocketId,\n          candidate: event.candidate\n        });\n      }\n    };\n\n    // Handle remote stream\n    peer.ontrack = (event) => {\n      const remoteStream = event.streams[0];\n      // You can emit this to components that need it\n      window.dispatchEvent(new CustomEvent('remote-stream', {\n        detail: { socketId: targetSocketId, stream: remoteStream }\n      }));\n    };\n\n    // Handle connection state changes\n    peer.onconnectionstatechange = () => {\n      console.log(`Peer connection state with ${targetSocketId}:`, peer.connectionState);\n      \n      if (peer.connectionState === 'failed' || peer.connectionState === 'disconnected') {\n        // Clean up failed connection\n        if (peersRef.current[targetSocketId]) {\n          peer.destroy();\n          delete peersRef.current[targetSocketId];\n        }\n      }\n    };\n\n    peersRef.current[targetSocketId] = peer;\n    return peer;\n  };\n\n  const handleOffer = async (offer, senderSocketId, senderUserName) => {\n    try {\n      const peer = createPeerConnection(senderSocketId, false);\n      await peer.setRemoteDescription(new RTCSessionDescription(offer));\n      const answer = await peer.createAnswer();\n      await peer.setLocalDescription(answer);\n\n      socket.emit('answer', {\n        targetSocketId: senderSocketId,\n        answer\n      });\n    } catch (error) {\n      console.error('Error handling offer:', error);\n    }\n  };\n\n  const handleAnswer = async (answer, senderSocketId) => {\n    try {\n      const peer = peersRef.current[senderSocketId];\n      if (peer) {\n        await peer.setRemoteDescription(new RTCSessionDescription(answer));\n      }\n    } catch (error) {\n      console.error('Error handling answer:', error);\n    }\n  };\n\n  const handleIceCandidate = async (candidate, senderSocketId) => {\n    try {\n      const peer = peersRef.current[senderSocketId];\n      if (peer) {\n        await peer.addIceCandidate(new RTCIceCandidate(candidate));\n      }\n    } catch (error) {\n      console.error('Error handling ICE candidate:', error);\n    }\n  };\n\n  const joinRoom = async (roomId, userName) => {\n    if (!socket) {\n      toast.error('Not connected to server');\n      return false;\n    }\n\n    try {\n      socket.emit('join-room', { roomId, userName });\n      setCurrentRoom(roomId);\n      return true;\n    } catch (error) {\n      console.error('Error joining room:', error);\n      toast.error('Failed to join room');\n      return false;\n    }\n  };\n\n  const leaveRoom = () => {\n    if (socket && currentRoom) {\n      // Emit leave-room event to server\n      socket.emit('leave-room', { roomId: currentRoom });\n      \n      setCurrentRoom(null);\n      setRoomUsers([]);\n      \n      // Clean up all peer connections\n      Object.values(peersRef.current).forEach(peer => {\n        if (peer) peer.destroy();\n      });\n      peersRef.current = {};\n      \n      // Stop local stream\n      if (localStreamRef.current) {\n        localStreamRef.current.getTracks().forEach(track => track.stop());\n        localStreamRef.current = null;\n      }\n      \n      toast.info('Left the room');\n    }\n  };\n\n  const getLocalStream = async (video = true, audio = true) => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        video: video ? {\n          width: { ideal: 1280 },\n          height: { ideal: 720 },\n          frameRate: { ideal: 30 }\n        } : false,\n        audio: audio ? {\n          echoCancellation: true,\n          noiseSuppression: true,\n          autoGainControl: true\n        } : false\n      });\n\n      localStreamRef.current = stream;\n      return stream;\n    } catch (error) {\n      console.error('Error accessing media devices:', error);\n      toast.error('Failed to access camera/microphone');\n      throw error;\n    }\n  };\n\n  const startCall = async (targetSocketId) => {\n    try {\n      const peer = createPeerConnection(targetSocketId, true);\n      const offer = await peer.createOffer();\n      await peer.setLocalDescription(offer);\n\n      socket.emit('offer', {\n        targetSocketId,\n        offer\n      });\n    } catch (error) {\n      console.error('Error starting call:', error);\n      toast.error('Failed to start call');\n    }\n  };\n\n  const toggleVideo = () => {\n    if (localStreamRef.current) {\n      const videoTrack = localStreamRef.current.getVideoTracks()[0];\n      if (videoTrack) {\n        videoTrack.enabled = !videoTrack.enabled;\n        return videoTrack.enabled;\n      }\n    }\n    return false;\n  };\n\n  const toggleAudio = () => {\n    if (localStreamRef.current) {\n      const audioTrack = localStreamRef.current.getAudioTracks()[0];\n      if (audioTrack) {\n        audioTrack.enabled = !audioTrack.enabled;\n        return audioTrack.enabled;\n      }\n    }\n    return false;\n  };\n\n  const startScreenShare = async () => {\n    try {\n      const screenStream = await navigator.mediaDevices.getDisplayMedia({\n        video: true,\n        audio: true\n      });\n\n      // Replace video track in all peer connections\n      const videoTrack = screenStream.getVideoTracks()[0];\n      Object.values(peersRef.current).forEach(peer => {\n        const sender = peer.getSenders().find(s => \n          s.track && s.track.kind === 'video'\n        );\n        if (sender) {\n          sender.replaceTrack(videoTrack);\n        }\n      });\n\n      // Listen for screen share end\n      videoTrack.onended = () => {\n        stopScreenShare();\n      };\n\n      socket.emit('screen-share-started');\n      return screenStream;\n    } catch (error) {\n      console.error('Error starting screen share:', error);\n      toast.error('Failed to start screen sharing');\n      throw error;\n    }\n  };\n\n  const stopScreenShare = async () => {\n    try {\n      // Get camera stream back\n      const cameraStream = await navigator.mediaDevices.getUserMedia({\n        video: true,\n        audio: true\n      });\n\n      const videoTrack = cameraStream.getVideoTracks()[0];\n      \n      // Replace screen track with camera track in all peer connections\n      Object.values(peersRef.current).forEach(peer => {\n        const sender = peer.getSenders().find(s => \n          s.track && s.track.kind === 'video'\n        );\n        if (sender) {\n          sender.replaceTrack(videoTrack);\n        }\n      });\n\n      // Update local stream\n      if (localStreamRef.current) {\n        const oldVideoTrack = localStreamRef.current.getVideoTracks()[0];\n        if (oldVideoTrack) {\n          localStreamRef.current.removeTrack(oldVideoTrack);\n          oldVideoTrack.stop();\n        }\n        localStreamRef.current.addTrack(videoTrack);\n      }\n\n      socket.emit('screen-share-stopped');\n      return cameraStream;\n    } catch (error) {\n      console.error('Error stopping screen share:', error);\n      toast.error('Failed to stop screen sharing');\n      throw error;\n    }\n  };\n\n  const value = {\n    socket,\n    isConnected,\n    roomUsers,\n    currentRoom,\n    joinRoom,\n    leaveRoom,\n    getLocalStream,\n    startCall,\n    toggleVideo,\n    toggleAudio,\n    startScreenShare,\n    stopScreenShare,\n    localStream: localStreamRef.current\n  };\n\n  return (\n    <SocketContext.Provider value={value}>\n      {children}\n    </SocketContext.Provider>\n  );\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}